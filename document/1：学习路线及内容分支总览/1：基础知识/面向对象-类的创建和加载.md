# 面向对象

## 类和对象

###创建和销毁
####类的创建方式：
    1). 使用new关键字创建对象
    2). 使用Class类的newInstance方法(反射机制)
    3). 使用Constructor类的newInstance方法(反射机制)
    4). 使用Clone方法创建对象
    5). 使用(反)序列化机制创建对象
    6). 完整实例
    
``` 
public class Student implements Cloneable, Serializable {

    private int id;

    public Student() {

    }

    public Student(Integer id) {
        this.id = id;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        // TODO Auto-generated method stub
        return super.clone();
    }

    @Override
    public String toString() {
        return "Student [id=" + id + "]";
    }

    public static void main(String[] args) throws Exception {

        System.out.println("使用new关键字创建对象：");
        Student stu1 = new Student(123);
        System.out.println(stu1);
        System.out.println("\n---------------------------\n");


        System.out.println("使用Class类的newInstance方法创建对象：");
        Student stu2 = Student.class.newInstance();    //对应类必须具有无参构造方法，且只有这一种创建方式
        System.out.println(stu2);
        System.out.println("\n---------------------------\n");

        System.out.println("使用Constructor类的newInstance方法创建对象：");
        Constructor<Student> constructor = Student.class
                .getConstructor(Integer.class);   // 调用有参构造方法
        Student stu3 = constructor.newInstance(123);   
        System.out.println(stu3);
        System.out.println("\n---------------------------\n");

        System.out.println("使用Clone方法创建对象：");
        Student stu4 = (Student) stu3.clone();
        System.out.println(stu4);
        System.out.println("\n---------------------------\n");

        System.out.println("使用(反)序列化机制创建对象：");
        // 写对象
        ObjectOutputStream output = new ObjectOutputStream(
                new FileOutputStream("student.bin"));
        output.writeObject(stu4);
        output.close();

        // 读取对象
        ObjectInputStream input = new ObjectInputStream(new FileInputStream(
                "student.bin"));
        Student stu5 = (Student) input.readObject();
        System.out.println(stu5);

        }
    }
}
```
####类的创建过程：
    当一个对象被创建时，虚拟机就会为其分配内存来存放对象自己的实例变量及其从父类继承过来的实例变量(即使这些从超类继承过来的实例变量有可能被隐藏也会被分配空间)。
    在为这些实例变量分配内存的同时，这些实例变量也会被赋予默认值(零值)。
    在内存分配完成之后，Java虚拟机就会开始对新创建的对象按照程序猿的意志进行初始化。
    在Java对象初始化过程中，主要涉及三种执行对象初始化的结构，分别是 实例变量初始化、实例代码块初始化 以及 构造函数初始化。
    
1、实例变量初始化与实例代码块初始化

    我们在定义（声明）实例变量的同时，还可以直接对实例变量进行赋值或者使用实例代码块对其进行赋值。
    如果我们以这两种方式为实例变量进行初始化，
    那么它们将在构造函数执行之前完成这些初始化操作。
    实际上，如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，
    并且这些代码会被放在对超类构造函数的调用语句之后(还记得吗？Java要求构造函数的第一条语句必须是超类构造函数的调用语句)，
    构造函数本身的代码之前。
    Java是按照编程顺序来执行实例变量初始化器和实例初始化器中的代码的，并且不允许顺序靠前的实例代码块初始化在其后面定义的实例变量
    
2、构造函数初始化

    我们可以从上文知道，实例变量初始化与实例代码块初始化总是发生在构造函数初始化之前，那么我们下面着重看看构造函数初始化过程。
    众所周知，每一个Java中的对象都至少会有一个构造函数，如果我们没有显式定义构造函数，那么它将会有一个默认无参的构造函数。
    在编译生成的字节码中，这些构造函数会被命名成<init>()方法，参数列表与Java语言书写的构造函数的参数列表相同。
    我们知道，Java要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。
    事实上，这一点是在构造函数中保证的：
    Java强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，
    如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用，
    
3、 小结

    总而言之，实例化一个类的对象的过程是一个典型的递归过程，如下图所示。进一步地说，在实例化一个类的对象时，具体过程是这样的：
    在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到Object类。
    此时，首先实例化Object类，再依次对以下各类进行实例化，直到完成对目标类的实例化。
    具体而言，在实例化每个类时，都遵循如下顺序：先依次执行实例变量初始化和实例代码块初始化，再执行构造函数初始化。
    也就是说，编译器会将实例变量初始化和实例代码块初始化相关代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后，构造函数本身的代码之前。
    >![实例化类的过程](https://img-blog.csdn.net/20170518135452979?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast '实例化类的过程')

#### 类的初始化过程：
new类名

1、根据new的参数在常量池中定位一个类的符号引用  
2、如果没有找到这个符号引用，说明类还没有被加载，则进行类的加载，解析和初始化  
3、虚拟机为对象分配内存（位于堆中）  
4、将分配的内存初始化为0值（不包括对象头）  
5、调用对象的init方法  

    jvm首先回去方法去的常量池中定位这个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析和初始化过，如果没有，就必须先执行相应的类加载过程
+ 类加载过程：加载-》验证-》准备-》解析-》初始化-》使用-》卸载-》
     + 1：通过一个类的全限定名来获取定义的二进制字节流（不止class文件中获取，还可以从jar包中获取，从网络中获取，等）
     + 2：将这个字节流锁代表的静态存储结构转换为方法区的运行时数据结构
     + 3：在java堆中生成一个代表这个类的java.lang.class对象，作为方法去中这些数据的访问入口
+ 类加载器 ：
     + 1：分为以下3种
        + 启动类加载器: Bootstrap ClassLoader,它负责加载存放在JDK\jre\lib目录下，或者是指定路径中，能被虚拟机识别的类库
        + 扩展类加载器: Extension ClassLoader,该加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）
        + 应用程序类加载器：Application ClassLoader 负责加载用户路径（ClassPath）所指定的类，*一般情况下这个就是程序的默认启动加载器*
        + 类加载的顺序为下图所示 这种层次关系我们称为双亲委派模式，我们把每一层上面的类加载叫做当前层类的父加载器，这种父子关系不是继承实现的，而是用组合的关系来复用父加载器中的代码，这个不是一个强制性的约束模型，而是java设计者们推荐给开发的一种类加载器的实现方式
![](https://img-blog.csdn.net/20140105211242593)
        + 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。因此，所有的类加载请求最终都应该被传递到顶层的类加载器中，只有当父加载器在它搜索的范围中没有找到所需类时，即无法完成该加载，子类加载器才会去尝试自己加载此类。
        + 使用双亲委派模型来组织类加载器之间的关系，明显的好处，就是java类随着他的类加载器（就是它的目录)一起具备了一种带有优先级的层次关系，保证了java程序的稳定运行。无论哪个类要加载此类，最终都会委派个启动类加载器进行加载，保证了Object类在程序中的各种类加载器中都是同一个类。
     + 验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能有所不同，但大致都会完成以下4个阶段的验证：
        + 文件格式的验证、元数据的验证、字节码的验证
        + 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确的解析并存储于方法区内。进过该阶段的验证后，字节流才会进入内存的方法区进行存储，后面三个验证都是基于方法区的存储结构进行的。
        + 元数据验证：对类的元数据信息进行语义校验（其实就是对勒种的各数据类型进行语法校验），保证不存在不符合java语法规范的元数据信息
        + 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
            + 危害虚拟机安全的行为例如：修改编译后的字节码文件，运行字节码文件时就会报错
        + 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转换为直接引用的时候，主要是对类自身以外的信息进行匹配性的校验
     + 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配，对于该阶段有以下几点需要注意
        + 1：这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在java堆中
        + 2：这里所设置的初始值通常情况下是数据类型默认的0值，而不是在java代码中被显式赋予的值。
     + 解析：解析阶段是虚拟机将常量池中的符号引用转换为直接引用的过程。解析阶段可能在初始化之前，也可能在初始化之后，虚拟机会根据需要来自行判断，对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存，从而避免解析动作重复执行。
        + 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。
            + 类或接口的解析：判断所要转换成的直接引用是对数组类型还是普通的对象类型的引用，从而进行不同的解析
            + 字段解析：对字段进行解析时，会现在奔雷中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束，如果没有，则会按照集成关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照集成关系从上往下递归搜索父类，直至查找结束。
            + 类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口
            + 接口方法解析： 与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行
     + 初始化：初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的java程序代码，在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是程序员通过程序制定的主观计划去初始化类变量和其他资源。

总结：整个类加载中，除了在加载阶段用户应用程序可以自定义类加载器参与以外，其余所有动作完全由虚拟机主导和控制。到了初始化阶段才开始执行类中定义的java程序代码（字节码），但这里执行代码只是一个开端，它仅限于clinit（）方法。类加载过程中主要是将Class文件加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。

###总结

　1、一个实例变量在对象初始化的过程中会被赋值几次？

    我们知道，JVM在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个时候实例变量被第一次赋值，这个赋值过程是没有办法避免的。
    如果我们在声明实例变量x的同时对其进行了赋值操作，那么这个时候，这个实例变量就被第二次赋值了。
    如果我们在实例代码块中，又对变量x做了初始化操作，那么这个时候，这个实例变量就被第三次赋值了。
    如果我们在构造函数中，也对变量x做了初始化操作，那么这个时候，变量x就被第四次赋值。
    也就是说，在Java的对象初始化过程中，一个实例变量最多可以被初始化4次。
    
　2、类的初始化过程与类的实例化过程的异同？

    类的初始化是指类加载过程中的初始化阶段对类变量按照程序猿的意图进行赋值的过程；而类的实例化是指在类完全加载到内存中后创建对象的过程。

3、假如一个类还未加载到内存中，那么在创建一个该类的实例时，具体过程是怎样的？

    我们知道，要想创建一个类的实例，必须先将该类加载到内存并进行初始化，也就是说，类初始化操作是在类实例化操作之前进行的，
    但并不意味着：只有类初始化操作结束后才能进行类实例化操作。