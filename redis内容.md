Redis 部分

使用redis有哪些好处？
  + 支持超过100K+ 的每秒读写（速度快）
  + 丰富的数据类型：strings Lists hashes，Sets及Ordered Set数据类型的操作
  + 所有的操作都是原子性的，同时还支持对几个操作合并后的原子性操作
  + 还支持pubish/subscribe，通知、key过期等等特性
  + 持久化：对数据的更新采用copy-on-write技术，可以异步保存在磁盘上，主要有两种策略，一种是根据时间，更新次数的快照，二是基于语句追加的方式
  + 自动操作：对不同数据类型的操作都是自动的，安全性高
  + 快速的主-从复制
  + sharding技术，很容易将数据分布到多个redis实例中，
Redis与Memcached的区别与比较
  + memcached是多线程的，分为监听线程、worker线程、引入锁，带来了性能损耗，redis 使用单线程的IO复用模型，将速度优势发挥到最大，也提供了简单的计算功能
  + 内存管理方面，memcached使用预分配的内存池的方式，带来一定程度的空间浪费，并且在内存仍然有很大空间的时候，新的数据也可能被删除，而redis使用现场申请内存的方式来存储数据，不会剔除任何非临时数据，redis更适合作为存储而不是chche
  + 数据一致性：memcached提供了cas命令来保证，而redis提供了事务的功能，可以保证一串命令的原子性，中间不会被任何操作打断
  + 存储方面：memcached只支持简单的key-value存储，不支持美剧，不支持持久化和复制等功能
  +
Redis的两种持久化操作以及如何保障数据安全（快照和AOF）
  + 快照的方式，会损失部分数据
  + AOF（以日志的方式记录每次写命令），服务重启的时候重新执行AOF命令来恢复内存数据，因为解决了数据持久化实时性的问题，所以AOF是目前redis持久化的主流方式
如何防止数据出错（Redis事务）
  + Redis中事务是一组命令的集合，事务同命令一样都是Redis的最小执行单位，一个事务中的命令要么都执行，要么都不执行，事务的原理是先将一个事务的命令发送给Redis，然后再让Redis一次执行这些命令。
  + 和传统的事务不同，Redis的事务没有关系型数据库提供的回滚功能，为此开发者必须在事务执行出错后，自己收拾，我们一般才去日志记录然后业务补偿的访视来处理，但是一般情况下，在Redis做的操作不应该有这种强一致性的要求。
Redis主从复制
  + 主从复制是指将一台Redis服务器的数据，复制到其他Redis服务器，前者称为主节点，后者称为从节点，数据的复制是单向的，只能由主节点到从节点。默认情况下，每台Redis服务器都是主节点，且一个主节点可以有多个从节点，但是一个从节点只能有一个主节点。
  + 主从复制的主要作用是：数据冗余、故障恢复、负载均衡、高可用性
  + 开启主从复制有3种方式
    + 1、配置文件：从服务器的配置文件中加入 slaveof <masterip> <masterport>
    + 2、启动命令：redis-server启动命令后加入 --slaveof <masterip> <masterport>
    + 3、客户端命令：Redis服务器启动后，直接通过客户端执行命令：slaveof <masterip> <masterport>，则该Redis实例成为从节点。


Redis集群的搭建
  + Redis支持集群最小的单位为6个实例，3个主节点，3个从节点
  + 集群中有多个实例的时候，操作的时候无需关心是写入至哪个主节点，操作的是集群对象，
  + 如果其中一个master挂了，从节点会反客为主，如果挂掉的主节点再次启动的话，就会从主节点变为从节点。
  + 搭建：
    + 1：安装GCC
    + 2：编译安装Redis
    + 3：将redis-trib.rb 复制到 /usr/local/bin 目录下
    + 4：创建Redis节点
    + 5：启动Redis
    + 6：检查状态
    + 7：创建集群
      + 安装ruby
      + 创建集群
        + redis-trib.rb  create  --replicas  1  192.168.0.66:7000 192.168.0.66:7001 192.168.0.66:7002 192.168.0.67:7003 192.168.0.67:7004 192.168.0.67:7005
    + 8：验证集群

Redis的几种淘汰策略
+ volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
+ volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
+ volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
+ allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
+ allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
+ no-enviction（驱逐）：禁止驱逐数据
+ 注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。


Redis集群宕机，数据迁移问题
  + 集群宕机判断
    + 某个主节点和所有从节点全部挂掉，集群进入fail状态
    + 超过半数以上的master挂掉，集群进入fail状态
    + 任意一个master挂掉，并且这个master下没有slave，集群进入fail状态

Redis缓存使用有很多，怎么解决缓存雪崩和缓存穿透？
  + 缓存雪崩：由于原缓存失效，新缓存未写入Redis，原本需要访问缓存的数据都去请求数据库，结果对数据库造成巨大压力，严重会造成数据库宕机，从而造成整个系统崩溃
    + 解决办法：
      + 1：缓存的过期时间可以加入一个随机值，使得每个key的过期时间分开，不会在同一时间失效。
      + 2：缓存失效后，通过加锁或者队列来控制读取数据库写缓存的线程数量，比如对于某个key只允许一个线程查询数据和写缓存，其他线程等待
      + 3：可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存
      + 4：不同的key设置不同的过期时间，让缓存失效的时间点尽量均匀
      + 5：增加二级缓存，A1为原始缓存，A1失效时可以访问A2，A1缓存失效时间设置为短期，A2失效时间设置为长期
  + 缓存穿透：一般在Redis中取数据时，都是根据key去获取数据，如果这个key没有获取到数据，就会进入数据库查询，如果一个key一直是没有数据的，那就会一直在数据库中进行查询，增加数据库的压力
    + 解决办法：
      + 1：缓存key的空值，如果Redis查询到key为空值时，直接返回空值的结果，而不再次进行数据库查询
      + 2：采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤
