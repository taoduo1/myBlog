 Mysql 部分

有哪些数据库优化方面的经验?
mysql 中 myisam 与 innodb 的区别？
  + InnoDB：mysql 默认的事务型引擎，也是最重要和最广泛的存储引擎，它被设计成为大量的短期事务，短期事务大部分情况下是正常提交的，很少被回滚，innodb的性能与自动崩溃恢复的特性，使得它在非事务存储需求中也很流行，除非有特别的原因需要使用其他的存储引擎，否则应该优先考虑innodb引擎。
  + 在mysql 5.1及之前的版本，myisam是默认引擎，myisam 提供大量的特性，包括全文索引、压缩、空间函数等，但是 myisam并不支持事务及行级锁，而且一个毫无疑问的缺陷是崩溃后无法安全恢复。但是对于只读或者表比较小、可以忍受修复操作，则依然可以使用。
  + 1：存储结构：
    + myisam：每个myisam 在磁盘上存储分为三个文件，第一个文件的名字以表的名字开始，扩展名指出文件类型，.frm文件存储表定义，.MYD的文件存储数据文件，.MYI文件存储索引
    + innodb : 所有表都保存在同一个数据文件中(也可以是多个文件，或者独立的表空间文件)，InnoDB表的大小只受操作系统文件大小的限制，一般为2G
  + 2：存储空间
    + myisam: 可被压缩、存储空间较小，支持三种不同的存储格式：静态表、动态表、压缩表
    + innodb: 需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
  + 3：可移植性、备份及恢复
    + myisam: 数据是以文件的形式存储，所以在跨平台的数据转移中会很方便，在备份和恢复时可单独针对某个表进行操作。
    + innodb: 免费的方案是可以拷贝数据文件、备份binlog，或者用MySQLdump，在数据量达到几十个G的时候就比较痛苦
  + 4：事务支持
    + myisam: 强调的是性能，每次查询具有原子性，其执行速度比innodb块，但是不提供事务支持
    + innodb: 提供事务，支持事务，外部键等高级数据库功能。具有事务、回滚、和崩溃修复功能的事务安全型表
  + 5: AUTO_INCREMENT
    + myisam: 可以和其他字段一起建立联合索引，引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，可以根据前面几列进行排序后递增
    + innodb: InnoDB 中必须包含只有该字段的索引，引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列
  + 6：表锁差异
    + myisam: 只支持表级锁，用户在操作 myisam 表时，select、update、delete、insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以再表的尾部插入新的数据，
    + innodb: 支持事务和行级锁，是Innodb的最大特色，行锁大幅度提高了多用户并发操作的性能，但是innodb的行级锁，只是在where的逐渐是有效的，非主键的where都会锁全表
  + 7 表主键：
    + myisam: 允许没有任何索引和主键的表存在，索引都是保存行的地址
    + innodb:  如果没有设定主键或者非空唯一索引，系统就会生成一个6个字节的主键（用户不可见），数据是主索引的一部分，附加索引的是主索引的值
  + 9 表的具体行数：
    + myisam：保存有表的总行数，如果count(*)会直接取出该值
    + innodb: 没有保存表的总行数，如果用count(*)就会遍历整个表，消耗相当大，但是加了where之后，两个引擎处理的方式都一样
  + 10 外键
    + myisam: 不支持
    + InnoDB: 支持
  + 优缺点：
    + 通过上述的分析，基本上可以考虑使用 innodb 来代替 myisam引擎了，原因是innodb自身很多良好的特性，比如说事务支持，存储过程，视图，行级锁等等，在并发较多的情况下，innodb的表现肯定要比 myisam 强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势
  + 存储引擎选择的基本原则
    + 采用MyISAM引擎
      + R/W > 100:1 且update相对较少
      + 并发不高
      + 表数据量小
      + 硬件资源有限
    + 采用InnoDB引擎
      + R/W比较小，频繁更新大字段
      + 表数据量超过1000万，并发高
      + 安全性和可用性要求高
    + 采用Memory引擎
      + 有足够的内存
      + 对数据一致性要求不高，如在线人数和session等应用
      + 需要定期归档数据


mysql 中 varchar 与 char 的区别以及 varchar(50)中的 50 代表的涵义？
  + char(10) 长度固定，当数据至有3个字符时，也占用10分字符
  + varchar(10) 长度不固定，当数据有3个字符时，只会占用4个字符(1个字符长度用来保存字符的长度)
  + varchar(50) 中的50 代表是 50个字节


MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？
  + read unCommitted(未提交读)，没有提交的事务也是可以读取到的，容易产生脏读，虽然性能最优，但是在实际场景中很少引用。

  + read committed（读已提交），一个事务只能看到已经提交的事务的结果。可以避免脏读，但是会导致一次事务中，两次的查询结果不一样（不可重复读）,大部分系统使用此模式。
  + repeatable read (重复读)，事务的多次read不会受其他事务的影像，也就是说事务读到的是快照，并不是真正的数据，在这种模式下，有可能产生幻读，mysql通过间隙锁来避免幻读的问题。mysql默认模式
  + Serializable（串行化），是将所有读写操作完全串行执行，是所有隔离级别中最高的，串行化对资源的开销大，对并发支持不好，只在很少的场景下使用。
MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成（或称实现）的？
  + InnoDB是基于索引来完成行锁

  + innodb是将primary key index和相关的行数据共同放在B+树的叶节点；innodb一定会有一个primary key，secondary index查找的时候，也是通过找到对应的primary，再找对应的数据行

MySQL 中控制内存分配的全局参数，有哪些？
  + Mysql 内存分配规则是：用多少给多少，最高到配置的值，不是立即分配

  +
具体谈一下sql如何优化?
  + 子查询可以被替换为关联查询，子查询会创建临时表，查询完成后再删除临时表，子查询比关联查询多了临时表的创建与销毁的过程。
  + 其实多表的情况下，子查询和多表join都不是很推荐，可以通过单表查询
  + 跨数据库更新数据，可以先建临时表，将数据放入临时表中，再在本数据库内进行更新
explain是如何解析sql的？
  + id : sql执行顺利的标识，sql 从大到小的执行
  + select type : 查询类型
    + SIMPLE：简单的select（不适用union 和子查询等）
    + PRIMARY: 最外层的select
    + union: union 中第二个或者后面的select 语句
    + dependent union ：union 中第二个活后面的select语句，取决于外面的查询
    + union result ：union的结果
    + subquery ：子查询中的第一个select
    + dependent subquery ：子查询中第一个select，取决于外面的查询，即子查询以来与外层查询的结果
  + table：表示查询的表或者衍生表
  + partitions ：查询记录来自于哪个分区
  + type： 显示了连接使用了哪种类型，有无使用索引
    + system：表中只有一条数据，这个类型是特殊的const类型。
    + const：正对主键或唯一索引的等值查询扫描最多只返回一行数据const查询速度非常快，因为它仅仅读取一次即可。
    + eq_ref：此类型通常出现在多表join中，表示对于前表的每一个结果，都只能匹配到后表的一行结果，并且查询的比较操作通常是"=",查询效率较高
    + ref： 此类型通常出现在多表join中，针对于非唯一或非逐渐索引，或者是使用了最左前缀规则索引的查询
    + range：表示使用索引范围查询，通过索引字段范围获取表中部分数据记录，这个类型通常出现在 "=","<",">",">=","<=",IS NULL,BETWEEN,IN()，操作中，当type是range时，那么explain 输出的ref字段为NULL，并且key_len字段时此次查询中使用到索引最长的那个
    + index：表示全索引扫描，和ALL欸四，只不过ALL类型时全表扫描，而index类型仅仅扫描所有的索引，而不扫描数据。index类型通常出现在所要查询的数据直接在索引树中就可以获取到，而不需要扫描数据
    + ALL：表示全表扫描，这个类型时性能最差的查询之一，通常来说，我们的查询不应该出现ALL类型的查询
    + type性能比较
      + ALL < index < range ~ index_merge < ref < eq_ref < const < system
  + possible_keys: possible_keys 列指出mysql能使用哪个索引在该表中找到行，
  + key：显示mysql实际决定使用的索引
  + key_len ：显示MySQL 决定使用的键长度
  + ref：显示使用哪个列，或常数与key一起从表中选择行
  + rows：显示MySQL 认为它执行时必须检查的行数
  + Extra：该列包含MySQL解决查询的详细信息
    + distinct：一旦MySQL找到了与行联合匹配的行，就不再搜索了
    + not exists： MySQL优化了left join 一旦找到了匹配left join标准的行，就不再搜索了
    + range checked for each ：没有找到理想的索引，因此对于从前面表中来的每一个行组合，MySQL检查使用哪个索引，并用它来从表中返回行，这是使用索引最慢的连接之一。
    + using filesort：MySQL需要额外的排序操作，不能通过索引顺序达到排序效果，出现这个的时候都建议优化，因为这样的查询对CPU消耗巨大
    + using index ：覆盖索引扫描，表示查询再索引树中就可以查到所需数据，不用扫描表数据文件，往往说明性能不错
    + Using temporary：查询有使用临时表，一般出现在排序、分组和多表join的情况，查询效率不高，建议优化
    + Using where 使用了where 从句来限定那些行将与下一张表匹配或者是返回给用户
    +
分库分表
+ 原因及方案 ：
  + 用户请求太大：单台服务器tps有限，分库方案
  + 单库太大：服务器处理能力有限，切分成更小的库
  + 单表太大：索引膨胀，查询超时，切分成更小的表
+ 分库分表的方式方法：
  + 垂直切分和水平切分
    + 分库分表的顺序应该是先垂直分，后水平分
    + 垂直拆分：
      + 垂直分表：也就是大表拆小标，将一些不常用的字段、长度较长的字段拆分至扩展表中
      + 垂直分库：根据业务不同，将不同业务拆分至不同数据库中
    + 水平拆分
      + 水平分表：针对数据量巨大的单张表，按照一定规则，如：RANGE、HASH取模的方式，切分至多张表中，但是这些表还是在同一个库中，所以库级别的数据库操作还是有瓶颈，不建议使用
      + 水平分库分表：将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同，水平分库分表能够有效的缓解单机和单库的性能瓶颈压力。
      + 水平分库分表切分规则
        + range： 从0-10000一张表，10000-20000一张表
        + HASH取模：一个商场系统，一般都是将用户、订单作为主表，然后和他们相关的作为附表，这样不会造成跨库事务之类的问题，取用用户id，然后HASH取模，分配到不通的数据库上
        + 地理区域，比如按照华东、华南、华北这样来区分业务
        + 时间：按照时间切分，将每6个月的数据骑出去放在另外一张表中，随着时间流逝、这些表的数据被查询的概率变小，也是冷热数据分离
+ 分库分表后面临的问题
  + 事务支持：将单表数据切片后存储再多个数据库中，如果依靠数据库本身的事务机制不能满足所有场景的需求，但是我们需要本地事务尽可能一致，就需要解决分布式事务的问题
  + 主流的方案有三种，1，两段式提交协议，2，最大努力保证模式，3，事务补偿机制
  + 1：两段式提交协议：将事务分为两个阶段，一个是准备阶段，一个是提交阶段，两个阶段都由事务管理器发起，基于两阶段提交协议，事务管理器能够最大程度的保证跨数据库操作的事务的原子性，是分布式系统环境下最严格的事务实现方法。但是因为事务管理器需要和每个参与者进行准备和提交的操作协调，在准备阶段锁定资源，在提交阶段消费资源。如果参与者过多的话，锁定资源和消费资源之间的时间差被拉长，导致响应速度较慢，在此期间产生死锁或者不确定结果的可能性较大，所以，在互联网行业里，为了追求性能，很少使用两阶段提交模式
  + 2：最大努力保证模式：适用于对一致性要求并不严格，但是对性能要求较高的场景。具体实现方法是，在更新多个资源时，将多个资源的提交尽量延后到最后一刻处理，这样的话，如果业务流程出现问题，则所有的资源更新都可以回滚，事务仍然保持一致。唯一可能出现问题的情况是在提交多个资源时发生了系统故障、如网络问题等，但是这种情况时非常罕见的，一旦出现这种情况，就需要进行实时补偿，将已提交的事务进行回滚
  + 3：事务补偿机制：在数据库分表后，如果涉及的多个更新操作在某一数据库范围内完成，则可以使用数据库内的本地事务保证一致性，对于跨库的多个操作可通过补偿和重试，使其在一定的时间窗口内完成，这样就可以实现事务的最终一致性，突破事务一遇到问题就回滚的传统思路。
