*斜体文本*
_斜体文本_
**粗体文sss本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___
***
* * *
*****
- - -
----------
~~BAIDU.COM~~<u>带下划线文本</u>[^要注明的文本]
* 第一项
* 第二项
* 第三项
 [菜鸟教程](https://www.runoob.com)
 ![](http://static.runoob.com/images/runoob-logo.png)

 Mysql 部分

有哪些数据库优化方面的经验?
mysql 中 myisam 与 innodb 的区别？
  + InnoDB：mysql 默认的事务型引擎，也是最重要和最广泛的存储引擎，它被设计成为大量的短期事务，短期事务大部分情况下是正常提交的，很少被回滚，innodb的性能与自动崩溃恢复的特性，使得它在非事务存储需求中也很流行，除非有特别的原因需要使用其他的存储引擎，否则应该优先考虑innodb引擎。
  + 在mysql 5.1及之前的版本，myisam是默认引擎，myisam 提供大量的特性，包括全文索引、压缩、空间函数等，但是 myisam并不支持事务及行级锁，而且一个毫无疑问的缺陷是崩溃后无法安全恢复。但是对于只读或者表比较小、可以忍受修复操作，则依然可以使用。
  + 1：存储结构：
    + myisam：每个myisam 在磁盘上存储分为三个文件，第一个文件的名字以表的名字开始，扩展名指出文件类型，.frm文件存储表定义，.MYD的文件存储数据文件，.MYI文件存储索引
    + innodb : 所有表都保存在同一个数据文件中(也可以是多个文件，或者独立的表空间文件)，InnoDB表的大小只受操作系统文件大小的限制，一般为2G
  + 2：存储空间
    + myisam: 可被压缩、存储空间较小，支持三种不同的存储格式：静态表、动态表、压缩表
    + innodb: 需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
  + 3：可移植性、备份及恢复
    + myisam: 数据是以文件的形式存储，所以在跨平台的数据转移中会很方便，在备份和恢复时可单独针对某个表进行操作。
    + innodb: 免费的方案是可以拷贝数据文件、备份binlog，或者用MySQLdump，在数据量达到几十个G的时候就比较痛苦
  + 4：事务支持
    + myisam: 强调的是性能，每次查询具有原子性，其执行速度比innodb块，但是不提供事务支持
    + innodb: 提供事务，支持事务，外部键等高级数据库功能。具有事务、回滚、和崩溃修复功能的事务安全型表
  + 5: AUTO_INCREMENT
    + myisam: 可以和其他字段一起建立联合索引，引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，可以根据前面几列进行排序后递增
    + innodb: InnoDB 中必须包含只有该字段的索引，引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列
  + 6：表锁差异
    + myisam: 只支持表级锁，用户在操作 myisam 表时，select、update、delete、insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以再表的尾部插入新的数据，
    + innodb: 支持事务和行级锁，是Innodb的最大特色，行锁大幅度提高了多用户并发操作的性能，但是innodb的行级锁，只是在where的逐渐是有效的，非主键的where都会锁全表
  + 7 表主键：
    + myisam: 允许没有任何索引和主键的表存在，索引都是保存行的地址
    + innodb:  如果没有设定主键或者非空唯一索引，系统就会生成一个6个字节的主键（用户不可见），数据是主索引的一部分，附加索引的是主索引的值
  + 9 表的具体行数：
    + myisam：保存有表的总行数，如果count(*)会直接取出该值
    + innodb: 没有保存表的总行数，如果用count(*)就会遍历整个表，消耗相当大，但是加了where之后，两个引擎处理的方式都一样
  + 10 外键
    + myisam: 不支持
    + InnoDB: 支持
  + 优缺点：
    + 通过上述的分析，基本上可以考虑使用 innodb 来代替 myisam引擎了，原因是innodb自身很多良好的特性，比如说事务支持，存储过程，视图，行级锁等等，在并发较多的情况下，innodb的表现肯定要比 myisam 强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势
  + 存储引擎选择的基本原则
    + 采用MyISAM引擎
      + R/W > 100:1 且update相对较少
      + 并发不高
      + 表数据量小
      + 硬件资源有限
    + 采用InnoDB引擎
      + R/W比较小，频繁更新大字段
      + 表数据量超过1000万，并发高
      + 安全性和可用性要求高
    + 采用Memory引擎
      + 有足够的内存
      + 对数据一致性要求不高，如在线人数和session等应用
      + 需要定期归档数据


mysql 中 varchar 与 char 的区别以及 varchar(50)中的 50 代表的涵义？
  + char(10) 长度固定，当数据至有3个字符时，也占用10分字符
  + varchar(10) 长度不固定，当数据有3个字符时，只会占用4个字符(1个字符长度用来保存字符的长度)
  + varchar(50) 中的50 代表是 50个字节


MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？
  + read unCommitted(未提交读)，没有提交的事务也是可以读取到的，容易产生脏读，虽然性能最优，但是在实际场景中很少引用。

  + read committed（读已提交），一个事务只能看到已经提交的事务的结果。可以避免脏读，但是会导致一次事务中，两次的查询结果不一样（不可重复读）,大部分系统使用此模式。
  + repeatable read (重复读)，事务的多次read不会受其他事务的影像，也就是说事务读到的是快照，并不是真正的数据，在这种模式下，有可能产生幻读，mysql通过间隙锁来避免幻读的问题。mysql默认模式
  + Serializable（串行化），是将所有读写操作完全串行执行，是所有隔离级别中最高的，串行化对资源的开销大，对并发支持不好，只在很少的场景下使用。
MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成（或称实现）的？
  + InnoDB是基于索引来完成行锁

  + innodb是将primary key index和相关的行数据共同放在B+树的叶节点；innodb一定会有一个primary key，secondary index查找的时候，也是通过找到对应的primary，再找对应的数据行

MySQL 中控制内存分配的全局参数，有哪些？
  + Mysql 内存分配规则是：用多少给多少，最高到配置的值，不是立即分配

  +
具体谈一下sql如何优化?
  + 子查询可以被替换为关联查询，子查询会创建临时表，查询完成后再删除临时表，子查询比关联查询多了临时表的创建与销毁的过程。
  + 其实多表的情况下，子查询和多表join都不是很推荐，可以通过单表查询
  + 跨数据库更新数据，可以先建临时表，将数据放入临时表中，再在本数据库内进行更新
explain是如何解析sql的？
说一下order by原理

分库分表
