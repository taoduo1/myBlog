*斜体文本*
_斜体文本_
**粗体文sss本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___
***
* * *
*****
- - -
----------
~~BAIDU.COM~~<u>带下划线文本</u>[^要注明的文本]
* 第一项
* 第二项
* 第三项
 [菜鸟教程](https://www.runoob.com)
 ![](http://static.runoob.com/images/runoob-logo.png)
#JDK、 JRE、JVM 的关系是什么？
JDK是开发环境， JDK包含了JRE和JVM
jRE是运行环境，JRE包含了JVM
JVM是java虚拟机，运行java代码
#JVM 的内存模型以及分区情况和作用
+ jmm是jvm的一种规范，它的主要目的是解决由于多线程通过共享内存进行通讯是，存在的背刺内存数据不一致，编译器会对代码指令重排序，处理器会对代码乱序执行等带来的问题，可以保证并发编程场中中的原子性、可见性和有序性
java数据区域分为5打数据区域，这些区域各有各的用途、创建及销毁时间
+ java虚拟机管理将内存分为五大区域
方法区、堆、运行时数据区（程序计数器、本地方法栈、虚拟机栈）
1：程序计数器的用途是用来标记线程运行到哪一行代码的（因为程序是多线程的，线程进行切换的时候会需要记录程序运行到哪个地方了）
2：虚拟机栈里面有栈帧 描述的是java方法执行的内存模型（方法执行的时候会创建一堆栈帧，栈帧里面有局部变量表，方法返回地址，操作数栈，方法返回地址）
3：本地方法栈 和虚拟机栈差不多，是为虚拟机使用到的native方法服务（调用其他非java代码时使用）
4：所有的对象实例第一要在堆上分配内存，堆中的对象是线程共享的（堆就是所有对象存储的地方）
5：方法区也是所有线程共享的区域，用于存储已经被虚拟机加载的类的信息，常量、静态变量（老版本JDK中，这个地方就是永久代，因为没有强制要求必须要实现垃圾回收）

#JVM 对象创建步骤流程是什么？new()
new类名
1、根据new的参数在常量池中定位一个类的符号引用
2、如果没有找到这个符号引用，说明类还没有被加载，则进行类的加载，解析和初始化
3、虚拟机为对象分配内存（位于堆中）
4、将分配的内存初始化为0值（不包括对象头）
5、调用对象的init方法
jvm首先回去方法去的常量池中定位这个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析和初始化过，如果没有，就必须先执行相应的类加载过程
+ 类加载过程：加载-》验证-》准备-》解析-》初始化-》使用-》卸载-》
     + 1：通过一个类的全限定名来获取定义的二进制字节流（不止class文件中获取，还可以从jar包中获取，从网络中获取，等）
     + 2：将这个字节流锁代表的静态存储结构转换为方法区的运行时数据结构
     + 3：在java堆中生成一个代表这个类的java.lang.class对象，作为方法去中这些数据的访问入口
+ 类加载器 ：
     + 1：分为以下3种
        + 启动类加载器: Bootstrap ClassLoader,它负责加载存放在JDK\jre\lib目录下，或者是指定路径中，能被虚拟机识别的类库
        + 扩展类加载器: Extension ClassLoader,该加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）
        + 应用程序类加载器：Application ClassLoader 负责加载用户路径（ClassPath）所指定的类， **一般情况下这个就是程序的默认启动加载器**
        + 类加载的顺序为下图所示![](https://img-blog.csdn.net/20140105211242593) 这种层次关系我们称为双亲委派模式，我们把每一层上面的类加载叫做当前层类的父加载器，这种父子关系不是继承实现的，而是用组合的关系来复用父加载器中的代码，这个不是一个强制性的约束模型，而是java设计者们推荐给开发的一种类加载器的实现方式

        + 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。因此，所有的类加载请求最终都应该被传递到顶层的类加载器中，只有当父加载器在它搜索的范围中没有找到所需类时，即无法完成该加载，子类加载器才会去尝试自己加载此类。
        + 使用双亲委派模型来组织类加载器之间的关系，明显的好处，就是java类随着他的类加载器（就是它的目录)一起具备了一种带有优先级的层次关系，保证了java程序的稳定运行。无论哪个类要加载此类，最终都会委派个启动类加载器进行加载，保证了Object类在程序中的各种类加载器中都是同一个类。
     + 验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能有所不同，但大致都会完成以下4个阶段的验证：
        + 文件格式的验证、元数据的验证、字节码的验证
        + 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确的解析并存储于方法区内。进过该阶段的验证后，字节流才会进入内存的方法区进行存储，后面三个验证都是基于方法区的存储结构进行的。
        + 元数据验证：对类的元数据信息进行语义校验（其实就是对勒种的各数据类型进行语法校验），保证不存在不符合java语法规范的元数据信息
        + 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
            + 危害虚拟机安全的行为例如：修改编译后的字节码文件，运行字节码文件时就会报错
        + 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转换为直接引用的时候，主要是对类自身以外的信息进行匹配性的校验
     + 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配，对于该阶段有以下几点需要注意
        + 1：这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在java堆中
        + 2：这里所设置的初始值通常情况下是数据类型默认的0值，而不是在java代码中被显式赋予的值。
     + 解析：解析阶段是虚拟机将常量池中的符号引用转换为直接引用的过程。解析阶段可能在初始化之前，也可能在初始化之后，虚拟机会根据需要来自行判断，对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存，从而避免解析动作重复执行。
        + 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。
            + 类或接口的解析：判断所要转换成的直接引用是对数组类型还是普通的对象类型的引用，从而进行不同的解析
            + 字段解析：对字段进行解析时，会现在奔雷中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束，如果没有，则会按照集成关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照集成关系从上往下递归搜索父类，直至查找结束。
            + 类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口
            + 接口方法解析： 与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行
     + 初始化：初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的java程序代码，在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是程序员通过程序制定的主观计划去初始化类变量和其他资源。

总结：整个类加载中，除了在加载阶段用户应用程序可以自定义类加载器参与以外，其余所有动作完全由虚拟机主导和控制。到了初始化阶段才开始执行类中定义的java程序代码（字节码），但这里执行代码只是一个开端，它仅限于clinit（）方法。类加载过程中主要是将Class文件加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。

内存分配：虚拟机为新生对象分配内存，对象所需的内存会在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。
+ java堆内存的分配访视是取决于垃圾回收器是否带有压缩真理功能决定的，在使用Serial,ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表方式。
+ 指针碰撞：假设java堆内存是完全规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存仅仅是吧那个指针向空闲的空间那边挪动一段与对象大小相同的距离，这种分配方式被称为指针碰撞。
+ 空闲列表：假设java堆内存不是完全规整的，已使用的内存和空闲的内存是相互交错的。那就没办法使用指针碰撞的方式，虚拟机就必须维护一个列表，列表上记录哪些空间是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象，并同时更新列表上的记录，这种方式就被陈伟空闲列表。
+ 垃圾回收算法：标记复制：从根集合开始扫描出存活的对象，然后将存活的对象复制到一块新的没有使用的内存空间中，当要回收的空间中存活对象比较少的时候，这个方式比较高效。
+ 垃圾回收算法：标记清除：从跟集合开始扫描，对存活的对象进行标记，比较完成后，对没有标记的对象进行回收，不需要对对象进行移动压缩，所以这种算法的访视一般使用空闲列表的分配内存方法。
+ 垃圾回收算法：标记压缩：从根集合开始扫描，对存活的对象标记，比较完成后，没有标记的对象进行回收，对存活的对象在内存空间中进行移动，好处是减少了内存空间的碎片，缺点是成本比较高，这种方式一般用指针碰撞来分配内存。
+ TLAB（Thread Local Allocation Buffer）：把内存分配的操作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地县城分配缓冲区，那个线程要分配内存，就在那个线程的TLAB上分配，只有TLAB用完并分配新的内存时，在进行同步锁定。虚拟机是否使用TLAB,可以通过-XX：+/-UseTLAB参数来设定
+ 同步处理：对内存空间的操作进行同步处理–实际上虚拟机采用CAS配上失败重试的方式保证了更新操作的原子性。

内存空间初始化：内存分配完成后，虚拟机需要将分配到的内存空间进行初始化为0值（不包括对象头）如果使用TLAB，这一工作也可以提前到TLAB分配时处理，这一步操作保证了对象的实力在java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型的零值。

接下来，虚拟机要对对象进行必要的设置，例如这个对象如果是哪个类的实力，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等，这些信息存在对象的对象头中。

垃圾回收算法有几种类型？ 他们对应的优缺点又是什么？
+ 1：Mark-Sweep（标记-清除）算法　
  + 标记清除算法分为2个阶段，
    + 1：标记：标记的任务就是标记处所有需要被回收的对象
    + 2：清除，清除就是回收被标记的对象所占用的内存空间
  + 优点：实现容易
  + 缺点：容易产生内存碎片，碎片太多可能会导致后续过程中要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作
+ copying 复制算法
  + 将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，将还活着的对象复制到另一块上，然后把原来的这一块上的内存空间一次性清理掉，这样就不容易出现内存碎片的问题
  + 优点：实现简单，运行高效且不容易产生内存碎片
  + 缺点：可使用的内存变为原来的一半
+ Mark-Compact 标记整理算法
  + 该算法标记阶段和Mark-Sweep算法一样，但是在完成标记后，它不是直接清理可回收对象，而是将活着的对象都向内存的一端移动，然后清理掉边界以外的内存
+ Generational Collection（分代收集）算法
  + 分代手机算法是目前大部分JVM垃圾收集器采用的算法
  + 它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域
  + 一般情况下是将堆内存划分为**老年代**和**新生代**
  + 老年代的特点是每次垃圾收集时，只有少量对象需要被回收
  + 新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取合适的收集算法
  + **注意**：在堆去之外还有一个代就是永久代，它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。



简单介绍一下什么是类加载机制？
.class文件加载到jvm中，并对数据进行校验、转换、解析、初始化，使这些数据最终成为可以被jvm使用的java类型。
类的加载过程是什么？简单描述一下每个步骤
加载、验证、准备、初始化、卸载的开始顺序是确定的，**结束顺序不一定，解析及阶段可能在初始化之后才开始**
另外类加载机制无需等到程序中首次使用才进行，JVM预先加载某些类也是被允许的。

JVM 预定义的类加载器有哪几种？分别什么作用？
+ 启动类加载器
+ 拓展类加载器
+ 系统类加载器

什么是 Class 文件？ Class 文件主要的信息结构有哪些？
+ class文件是一种8位2进制刘文建、各个数据项按顺序紧密的从前向后排列，相邻的项之间没有间隙，这样可以使class文件非常紧凑，体积小，可以被JVM快速的加载到内存，并且只占据少量的内存空间。


+ java源文件被编译之后，每个类（或者接口）都单独占一个class文件，并且勒种的所有信息都会在class文件中有相应的描述，由于class文件很灵活，它甚至比java源文件有更强的描述能力。
+ class文件中的信息也是一项一项排列的，每项数据都有它的固定长度，有的占一个字节，有个占两个字节，还有的占4个字节和8个字节，可以把u1、u2、u3、看做class文件数据项的类型
+ 在class文件开头的4个字节，存放着class文件的魔数，这个魔数是class文件的标志，是一个固定的值：0XCAFEBAABE。这个魔数是判断一个文件是不是class文件的标准。
+ 紧接着魔数的4个字节是class文件的此版本号和主版本号，版本号的用途就是class文件在什么时候加入或者改变了哪些特性，不同版本的javac编译器编译的版本号可能不同，其实就是标识这个代码是java哪个版本编译的
+ 在版本号后面就是常量池相关的数据项。常量池中存放了文字字符串、常量值、当前类的类名、字段名、方法名、各个字段和方法的描述符、对当前类的字段和方法的引用信息，当前类对其他类的引用信息等。常量池还存放着以下几种符号应用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。

对象“对象已死” 是什么概念？
+ 在java垃圾回收之前，需要判断对象是不是已经死掉，只有死掉的对象才会被回收。
+ 如何判断对象是不是已经死掉有下面几种
  + 引用计数：给对象添加一个引用计数器，每当有一个对象引用时+1，引用失效时-1，任何时刻计数器为0时，对象就是不可能再被引用的
    + 特点：实现简单，效率高，单很难结局对象之间循环引用的问题
  + 可达性分析：通过一个起始点向下搜索，搜索搜走过的路径被称为引用链，当一个对象到起始点没有任何引用链相连，这个对象就是不可达的

Java 语言怎么实现跨平台的？
+ java代码被编译成.class文件（字节码）后，通过JVM翻译成机器码，不同平台下编译成成的字节码是一样的，由jvm生成应对不同机器码。
+ **跨平台的是java语言，不是JVM**


JVM 数据运行区，哪些会造成 OOM 的情况？
+ java应用程序再启动时会指定所需要的内存大小，它被分割成两个不同的区域：堆空间和永久代
+ 触发OutOfMemory最常见的原因就是应用程序需要的空间大，但是jvm提供的空间无法满足要求。
+ 场景大多有两种，一种是配置过小的堆内存，另一种就是程序问题：如死循环等

详细介绍一下对象在分带内存区域的分配过程？

G1 与 CMS 两个垃圾收集器的对比
+ CNS（Concurrent Mark and Sweep），是以牺牲吞吐量为代价来获得最短停顿时间的垃圾回收器，主要适用于对响应时间的侧重性大于吞吐量的场景，仅针对老年代的回收。
  + 没有采用压缩操作，而是简单的mark and sweep，同时维护了一个free list来管理内存空间，所以也产生了大量的内存碎片
  + mark and sweep 分为多个阶段，其中大部分的阶段的GC线程是和用户线程并发执行的，默认的GC线程数为物理CPU核心数的1/4.
  + 因为是并发的进行清理，所以必须预留部分堆空间给正在运行的应用程序，默认情况下在老年代使用了68%及以上的内存的时候就开始CMS

过程：
+ 初始标记 stop the word（在执行垃圾收集算法时，java应用程序的其他所有线程都会被挂起）
  + 一是标记老年代中所有的GC Roots 所指的直接对象，二是标记被年轻代中存活对象引用的直接对象，因为仅标记少量节点，所以很快就能完成。
+ 并发标记（垃圾手机线程与用户线程同时工作）
  + 在初始标记的基础上继续向下便利其他对象引用并进行标记，这个阶段会从初始标记阶段中所标记的节点向下检索，标记处所有老年代中存活的对象，注意此时会有部分对象的引用被改变。
+ 并发预清理
  + 前一个阶段在并行运行的时候，一些对象的引用已经发生了变化，当这些引用发生变化的时候，JVM会标记堆的这个区域为Dirty card，在本阶段，哪些能够从dirty card对象到达的对象也会被标记，这个标记做完之后，dirty card标记也会被清除。
  + 总的来讲，本阶段会并发的更新并发标记阶段的引用变化和查找在并发标记阶段新进入老年代的对象，如刚晋升的对象和直接被分配在老年代的对象，通过重新扫描，以减少下一阶段的工作
+ 可终止的并发预清理
    + 这个阶段尝试去承担STW的final Remark阶段足够多的工作，这个阶段持续的时间依赖很多因素，由于这个阶段是重复的做相同的事，直到条件满足（重复的次数、多少量的工作、持续时间等）才会停止。
+ 重新标记/最终标记（final Remark）
  + 本阶段也需要STW，通常来说此次暂停都会比较长，因为并发清理是并发执行的，对象的引用可能会发生改变，需要确保在清理之前保持一个正确的对象引用视图，那么就需要STW来处理复杂的情况

+ 并发清理
  + 使用标记-清除法回收老年代的垃圾对象，与用户线程并发执行
+ 并发标记重置
  + 清空现场，为下一次GC做准备。

**注：由于GMS没有任何的碎片整理机制，所以会产生大量的碎片，因此可能会发生即时堆的大小没有耗尽，但是从新生代晋升老年代缺失败的情况，此时 fallback 为Serial old从而引起一次fullGC(会进行碎片整理)，可以通过增加老年代的大小和Survivor区的大小以减少fullGC的发生**

**如果对象分配率高于CMS回收的效率，将导致CMS完成之前老年代就被填满，这种情况称为“并发模式失败”，同样也会引起fullGC，可以通过调节-XX：CMSInitiatingOccupancyFraction和新生代的堆大小来防止发生fullGC**

线上常用的 JVM 参数有哪些？
+ 数据区设置
  + Xms：初始堆大小
  + Xmx：最大堆大小
  + Xss：Java 每个线程的Stack大小
  + XX：NewSize=n：设置年轻代大小
  + XX：NewRatio=n：设置年轻代和年老代的比值。如：为 3，表示年轻代与年老代比值为 1:3，年轻代占整个年轻代年老代和的 1/4。
  + XX：SurvivorRatio=n：年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor区有两个。如：3，表示 Eden：Survivor=3：2，一个 Survivor 区占整个年轻代的 1/5。
  + XX：MaxPermSize=n：设置持久代大小。
+ 收集器设置
  + XX：+UseSerialGC：设置串行收集器
  + XX：+UseParallelGC:：设置并行收集器
  + XX：+UseParalledlOldGC：设置并行年老代收集器
  + XX：+UseConcMarkSweepGC：设置并发收集器
  + XX：+UseG1GC：G1收集器，Java9默认开启，无需设置


对象什么时候进入老年代？

jvm中有新生代、老年代两块区域，因为分代回收策略，新生代还会划分为Eden和两个Survivor区如图所示 ![](https://user-gold-cdn.xitu.io/2019/10/19/16de1708b4467998?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)。
程序运行过程中，新产生的对象都会分配在Eden区，随着时间的推移，Eden区就满了，那么这个时候就会进行Minor GC进行清理。判断对象的年龄有以下方式
+ 1 根据对象年龄：jvm会给对象增加一个年龄的计数器，对象每进过一次GC，年龄就+1，待对象的年龄达到设置的阈值的时候就会被移动到老年代(默认的阈值是15)。也可以通过 **-XX:MaxTenuringThreshold** 调整
+ 2: 动态年龄判断：根据对象年龄有另外一个策略也会让对象进入老年代，大致规则就是假如当前放对象的Survivor，一批对象的总大小大于这块Survivor内存的50%，那么大于这批对象年龄的对象，就可以直接进入老年代了。也就是年龄1+年龄2+年龄n的多个对象总和超过Survivor区的50%，那么就会把年龄n以上的对象都放入老年代
+ 3：大对象直接进入老年代：如果设置了 **-XX:PretenureSizeThreshold** 参数 那么你要创建的对象大于这个参数的值，如果分配了一个超大的字节数组，此时就直接把这个大对象放入老年代，不会进入新生代。这样就可以避免大对象在新生代，屡次躲过GC，还要把他们复制来复制去的，最后才进入老年代。

什么是内存溢出， 内存泄露？ 他们的区别是什么？
+ 内存溢出是指程序再申请内存后，没有足够的内存供其使用。比如定义了一个Integer 但是给了它一个long才能存下的数，就会发生内存溢出。
+ 内存泄露是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但是内存泄露堆积后，迟早会导致内存溢出。

引起类加载操作的行为有哪些？
虚拟机规范严格规定了有且只有以下5种情况的时候必须立刻对类进行初始化。
+ 为一个类型创建一个新的对象实例时（比如new、反射、序列化）
+ 1：调用一个类型的静态方法时（即在字节码中执行invokestatic指令）
+ 2：调用一个类型或接口的静态字段，或者对这些静态字段执行赋值操作时（即在字节码中，执行getstatic或者putstatic指令），不过用final修饰的静态字段除外，它被初始化为一个编译时常量表达式
+ 3：调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法）
+ 4：初始化一个类的派生类时（Java虚拟机规范明确要求初始化一个类时，它的超类必须提前完成初始化操作，接口例外）
+ 5：JVM启动包含main方法的启动类时


介绍一下 JVM 提供的常用工具
Full GC 、 Major GC 、Minor GC 之间区别？
+ Minor GC 从年轻代空间回收内存被称为Minor GC
  + 当JVM无法为一个新对象分配空间是会触发Minor GC，比如说Eden空间满了，所以分配率越高，月频繁执行Minor GC
  + 内存池被填满的时候，其中的内容全部会被复制，指正会从0开始跟踪空闲内存。Eden和survivor去进行了标记和复制操作，取代了经典的标记、扫描、压缩、清理操作。所以Eden和survivor区不存在内存碎片。写指针总是停留在所使用内存池的顶部
  + 执行Minor GC 操作时，不会影响永久。从永久代到年轻代的引用被当成GC roots，从年轻代到永久代的引用在标记阶段被直接忽略掉。
  + 所有的Minor GC 都会触发STW，对于大部分应用程序，停顿导致的延迟都是可以忽略不计的，原因是大部分Eden区中的对象都能被认为是垃圾，永远也不会被复制到survivor去或者老年代空间，如果正好相反，Eden区大部分新生对象不符合GC条件，Minor GC 执行时暂停的时间将会长很多。

+ Major GC 是清理老年代 出现Major GC 通常会出现至少一次Minor GC
+ Full GC 是清理整个堆空间，包括年轻代和老年代的全局范围的GC

什么时候触发 Full GC ？
+ 调用System.gc时，系统建议执行Full GC，但是不必然执行
+ 老年代空间不足
+ 方法区空间不足
+ 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
+ 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小


什么情况下会出现栈溢出
+ 栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包含了基本数据类型、引用数据类型
+ 所以，栈溢出就是方法执行的时候创建的栈帧超过了栈的深度，那么最有可能的就是方法递归调用产生了这个结果（1：栈太小、2：方法递归调用死循环导致）


说一下强引用、软引用、弱引用、虚引用以及他们之间和 gc 的关系

Eden 和 Survivor 的比例分配是什么情况？为什么？
+ Eden + 2个survivor 比例为8:2，一个Eden，新生代出生的地方，两个survivor 一个用来保存上次新生代GC存活下来的对象，还有一个空着，在新生代GC时把Eden+ survivor中存活的对象复制到这个空的survivor中，一般一次GC后，新生代活下来的对象很少（这也是为什么新生代GC用复制算法），所以这个survivor也比较小。

CPU 资源占用过高怎么办
  + 1：上机器，用top命令查看CPU，内存等使用情况
  + 2：定位问题线程 ，使用ps -mp pid -o THREAD,tid,time 查看哪个线程的占用率高
  + 3：查看问题线程堆栈，将线程id转为16进制，然后用jstack 打印线程堆栈信息，jstack pid |grep tid（16进制线程id）
  + 4：查看到是哪个线程后，推测问题原因点
  + 5：使用jmap命令导出heapdump文件，然后拿到本地使用jvisualvm.exe分析。jmap [option] vmid ,jstack [option] vmid
  + 6:从heapdump文件中定位到程序中的工作现场，和内存状况，
  + 7：查看文件中哪些类的实例多，使用大小等，推测对应的哪些类出现问题，然后看对应代码找出问题

OOM 异常排查
  + 先重启服务器
  + 用top查看服务器的大概情况，主要是看内存是否应分配不够导致
  + dump 下服务器的jvm堆的快照，假设配置了-XX:+HeapDumpOnOutOfMemoryError, 在发生OOM的时候会在-XX:HeapDumpPath生成堆的dump文件，对dump文件进行分析。查找出发生OOM的原因


05 Java 基础部分

HashMap和ConcurrentHashMap区别
jdk1.8/jdk1.7都分别新增了哪些特性？


面向对象和面向过程的区别
什么是字节码?采用字节码的好处是什么?
Java 应用程序与小程序之间有那些差别
在一个静态方法内调用一个非静态成员为什么是非法的
在 Java 中定义一个不做事且没有参数的构造方法的作用
