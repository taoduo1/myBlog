*斜体文本*
_斜体文本_
**粗体文sss本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___
***
* * *
*****
- - -
----------
~~BAIDU.COM~~<u>带下划线文本</u>[^要注明的文本]
* 第一项
* 第二项
* 第三项
 [菜鸟教程](https://www.runoob.com)
 ![](http://static.runoob.com/images/runoob-logo.png)
#JDK、 JRE、JVM 的关系是什么？
JDK是开发环境， JDK包含了JRE和JVM
jRE是运行环境，JRE包含了JVM
JVM是java虚拟机，运行java代码
#JVM 的内存模型以及分区情况和作用
+ jmm是jvm的一种规范，它的主要目的是解决由于多线程通过共享内存进行通讯是，存在的背刺内存数据不一致，编译器会对代码指令重排序，处理器会对代码乱序执行等带来的问题，可以保证并发编程场中中的原子性、可见性和有序性
java数据区域分为5打数据区域，这些区域各有各的用途、创建及销毁时间
+ java虚拟机管理将内存分为五大区域
方法区、堆、运行时数据区（程序计数器、本地方法栈、虚拟机栈）
1：程序计数器的用途是用来标记线程运行到哪一行代码的（因为程序是多线程的，线程进行切换的时候会需要记录程序运行到哪个地方了）
2：虚拟机栈里面有栈帧 描述的是java方法执行的内存模型（方法执行的时候会创建一堆栈帧，栈帧里面有局部变量表，方法返回地址，操作数栈，方法返回地址）
3：本地方法栈 和虚拟机栈差不多，是为虚拟机使用到的native方法服务（调用其他非java代码时使用）
4：所有的对象实例第一要在堆上分配内存，堆中的对象是线程共享的（堆就是所有对象存储的地方）
5：方法区也是所有线程共享的区域，用于存储已经被虚拟机加载的类的信息，常量、静态变量（老版本JDK中，这个地方就是永久代，因为没有强制要求必须要实现垃圾回收）

#JVM 对象创建步骤流程是什么？new()
new类名
1、根据new的参数在常量池中定位一个类的符号引用
2、如果没有找到这个符号引用，说明类还没有被加载，则进行类的加载，解析和初始化
3、虚拟机为对象分配内存（位于堆中）
4、将分配的内存初始化为0值（不包括对象头）
5、调用对象的init方法
jvm首先回去方法去的常量池中定位这个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析和初始化过，如果没有，就必须先执行相应的类加载过程
+ 类加载过程：加载-》验证-》准备-》解析-》初始化-》使用-》卸载-》
     + 1：通过一个类的全限定名来获取定义的二进制字节流（不止class文件中获取，还可以从jar包中获取，从网络中获取，等）
     + 2：将这个字节流锁代表的静态存储结构转换为方法区的运行时数据结构
     + 3：在java堆中生成一个代表这个类的java.lang.class对象，作为方法去中这些数据的访问入口
+ 类加载器 ：
     + 1：分为以下3种
        + 启动类加载器: Bootstrap ClassLoader,它负责加载存放在JDK\jre\lib目录下，或者是指定路径中，能被虚拟机识别的类库
        + 扩展类加载器: Extension ClassLoader,该加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）
        + 应用程序类加载器：Application ClassLoader 负责加载用户路径（ClassPath）所指定的类， **一般情况下这个就是程序的默认启动加载器**
        + 类加载的顺序为下图所示![](https://img-blog.csdn.net/20140105211242593) 这种层次关系我们称为双亲委派模式，我们把每一层上面的类加载叫做当前层类的父加载器，这种父子关系不是继承实现的，而是用组合的关系来复用父加载器中的代码，这个不是一个强制性的约束模型，而是java设计者们推荐给开发的一种类加载器的实现方式

        + 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。因此，所有的类加载请求最终都应该被传递到顶层的类加载器中，只有当父加载器在它搜索的范围中没有找到所需类时，即无法完成该加载，子类加载器才会去尝试自己加载此类。
        + 使用双亲委派模型来组织类加载器之间的关系，明显的好处，就是java类随着他的类加载器（就是它的目录)一起具备了一种带有优先级的层次关系，保证了java程序的稳定运行。无论哪个类要加载此类，最终都会委派个启动类加载器进行加载，保证了Object类在程序中的各种类加载器中都是同一个类。
     + 验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能有所不同，但大致都会完成以下4个阶段的验证：
        + 文件格式的验证、元数据的验证、字节码的验证
        + 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确的解析并存储于方法区内。进过该阶段的验证后，字节流才会进入内存的方法区进行存储，后面三个验证都是基于方法区的存储结构进行的。
        + 元数据验证：对类的元数据信息进行语义校验（其实就是对勒种的各数据类型进行语法校验），保证不存在不符合java语法规范的元数据信息
        + 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
            + 危害虚拟机安全的行为例如：修改编译后的字节码文件，运行字节码文件时就会报错
        + 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转换为直接引用的时候，主要是对类自身以外的信息进行匹配性的校验
     + 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配，对于该阶段有以下几点需要注意
        + 1：这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在java堆中
        + 2：这里所设置的初始值通常情况下是数据类型默认的0值，而不是在java代码中被显式赋予的值。
     + 解析：解析阶段是虚拟机将常量池中的符号引用转换为直接引用的过程。解析阶段可能在初始化之前，也可能在初始化之后，虚拟机会根据需要来自行判断，对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存，从而避免解析动作重复执行。
        + 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。
            + 类或接口的解析：判断所要转换成的直接引用是对数组类型还是普通的对象类型的引用，从而进行不同的解析
            + 字段解析：对字段进行解析时，会现在奔雷中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束，如果没有，则会按照集成关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照集成关系从上往下递归搜索父类，直至查找结束。
            + 类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口
            + 接口方法解析： 与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行
     + 初始化：初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的java程序代码，在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是程序员通过程序制定的主观计划去初始化类变量和其他资源。

总结：整个类加载中，除了在加载阶段用户应用程序可以自定义类加载器参与以外，其余所有动作完全由虚拟机主导和控制。到了初始化阶段才开始执行类中定义的java程序代码（字节码），但这里执行代码只是一个开端，它仅限于clinit（）方法。类加载过程中主要是将Class文件加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。

内存分配：虚拟机为新生对象分配内存，对象所需的内存会在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。
+ java堆内存的分配访视是取决于垃圾回收器是否带有压缩真理功能决定的，在使用Serial,ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表方式。
+ 指针碰撞：假设java堆内存是完全规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存仅仅是吧那个指针向空闲的空间那边挪动一段与对象大小相同的距离，这种分配方式被称为指针碰撞。
+ 空闲列表：假设java堆内存不是完全规整的，已使用的内存和空闲的内存是相互交错的。那就没办法使用指针碰撞的方式，虚拟机就必须维护一个列表，列表上记录哪些空间是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象，并同时更新列表上的记录，这种方式就被陈伟空闲列表。
+ 垃圾回收算法：标记复制：从根集合开始扫描出存活的对象，然后将存活的对象复制到一块新的没有使用的内存空间中，当要回收的空间中存活对象比较少的时候，这个方式比较高效。
+ 垃圾回收算法：标记清除：从跟集合开始扫描，对存活的对象进行标记，比较完成后，对没有标记的对象进行回收，不需要对对象进行移动压缩，所以这种算法的访视一般使用空闲列表的分配内存方法。
+ 垃圾回收算法：标记压缩：从根集合开始扫描，对存活的对象标记，比较完成后，没有标记的对象进行回收，对存活的对象在内存空间中进行移动，好处是减少了内存空间的碎片，缺点是成本比较高，这种方式一般用指针碰撞来分配内存。
+ TLAB（Thread Local Allocation Buffer）：把内存分配的操作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地县城分配缓冲区，那个线程要分配内存，就在那个线程的TLAB上分配，只有TLAB用完并分配新的内存时，在进行同步锁定。虚拟机是否使用TLAB,可以通过-XX：+/-UseTLAB参数来设定
+ 同步处理：对内存空间的操作进行同步处理–实际上虚拟机采用CAS配上失败重试的方式保证了更新操作的原子性。

内存空间初始化：内存分配完成后，虚拟机需要将分配到的内存空间进行初始化为0值（不包括对象头）如果使用TLAB，这一工作也可以提前到TLAB分配时处理，这一步操作保证了对象的实力在java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型的零值。

接下来，虚拟机要对对象进行必要的设置，例如这个对象如果是哪个类的实力，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等，这些信息存在对象的对象头中。

垃圾回收算法有几种类型？ 他们对应的优缺点又是什么？
+ 1：Mark-Sweep（标记-清除）算法　
  + 标记清除算法分为2个阶段，
    + 1：标记：标记的任务就是标记处所有需要被回收的对象
    + 2：清除，清除就是回收被标记的对象所占用的内存空间
  + 优点：实现容易
  + 缺点：容易产生内存碎片，碎片太多可能会导致后续过程中要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作
+ copying 复制算法
  + 将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，将还活着的对象复制到另一块上，然后把原来的这一块上的内存空间一次性清理掉，这样就不容易出现内存碎片的问题
  + 优点：实现简单，运行高效且不容易产生内存碎片
  + 缺点：可使用的内存变为原来的一半
+ Mark-Compact 标记整理算法
  + 该算法标记阶段和Mark-Sweep算法一样，但是在完成标记后，它不是直接清理可回收对象，而是将活着的对象都向内存的一端移动，然后清理掉边界以外的内存
+ Generational Collection（分代收集）算法
  + 分代手机算法是目前大部分JVM垃圾收集器采用的算法
  + 它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域
  + 一般情况下是将堆内存划分为**老年代**和**新生代**
  + 老年代的特点是每次垃圾收集时，只有少量对象需要被回收
  + 新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取合适的收集算法
  + **注意**：在堆去之外还有一个代就是永久代，它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。



简单介绍一下什么是类加载机制？
.class文件加载到jvm中，并对数据进行校验、转换、解析、初始化，使这些数据最终成为可以被jvm使用的java类型。
类的加载过程是什么？简单描述一下每个步骤
加载、验证、准备、初始化、卸载的开始顺序是确定的，**结束顺序不一定，解析及阶段可能在初始化之后才开始**
另外类加载机制无需等到程序中首次使用才进行，JVM预先加载某些类也是被允许的。

JVM 预定义的类加载器有哪几种？分别什么作用？
+ 启动类加载器
+ 拓展类加载器
+ 系统类加载器

什么是 Class 文件？ Class 文件主要的信息结构有哪些？
+ class文件是一种8位2进制刘文建、各个数据项按顺序紧密的从前向后排列，相邻的项之间没有间隙，这样可以使class文件非常紧凑，体积小，可以被JVM快速的加载到内存，并且只占据少量的内存空间。


+ java源文件被编译之后，每个类（或者接口）都单独占一个class文件，并且勒种的所有信息都会在class文件中有相应的描述，由于class文件很灵活，它甚至比java源文件有更强的描述能力。
+ class文件中的信息也是一项一项排列的，每项数据都有它的固定长度，有的占一个字节，有个占两个字节，还有的占4个字节和8个字节，可以把u1、u2、u3、看做class文件数据项的类型
+ 在class文件开头的4个字节，存放着class文件的魔数，这个魔数是class文件的标志，是一个固定的值：0XCAFEBAABE。这个魔数是判断一个文件是不是class文件的标准。
+ 紧接着魔数的4个字节是class文件的此版本号和主版本号，版本号的用途就是class文件在什么时候加入或者改变了哪些特性，不同版本的javac编译器编译的版本号可能不同，其实就是标识这个代码是java哪个版本编译的
+ 在版本号后面就是常量池相关的数据项。常量池中存放了文字字符串、常量值、当前类的类名、字段名、方法名、各个字段和方法的描述符、对当前类的字段和方法的引用信息，当前类对其他类的引用信息等。常量池还存放着以下几种符号应用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。

对象“对象已死” 是什么概念？
+ 在java垃圾回收之前，需要判断对象是不是已经死掉，只有死掉的对象才会被回收。
+ 如何判断对象是不是已经死掉有下面几种
  + 引用计数：给对象添加一个引用计数器，每当有一个对象引用时+1，引用失效时-1，任何时刻计数器为0时，对象就是不可能再被引用的
    + 特点：实现简单，效率高，单很难结局对象之间循环引用的问题
  + 可达性分析：通过一个起始点向下搜索，搜索搜走过的路径被称为引用链，当一个对象到起始点没有任何引用链相连，这个对象就是不可达的

Java 语言怎么实现跨平台的？
+ java代码被编译成.class文件（字节码）后，通过JVM翻译成机器码，不同平台下编译成成的字节码是一样的，由jvm生成应对不同机器码。
+ **跨平台的是java语言，不是JVM**


JVM 数据运行区，哪些会造成 OOM 的情况？
详细介绍一下对象在分带内存区域的分配过程？
G1 与 CMS 两个垃圾收集器的对比
线上常用的 JVM 参数有哪些？
对象什么时候进入老年代？
什么是内存溢出， 内存泄露？ 他们的区别是什么？
引起类加载操作的行为有哪些？
介绍一下 JVM 提供的常用工具
Full GC 、 Major GC 、Minor GC 之间区别？
什么时候触发 Full GC ？
什么情况下会出现栈溢出
说一下强引用、软引用、弱引用、虚引用以及他们之间和 gc 的关系
Eden 和 Survivor 的比例分配是什么情况？为什么？
CPU 资源占用过高怎么办
OOM 异常排查

04 JVM 部分

内存模型以及分区，需要详细到每个区放什么
对象创建方法，对象的内存分配，对象的访问定位。
GC 收集器有哪些？CMS 收集器与 G1 收集器的特点
Minor GC 与 Full GC 分别在什么时候发生？
JVM 内存分哪几个区，每个区的作用是什么?
如和判断一个对象是否存活?(或者 GC 对象的判定方法)
05 Java 基础部分

HashMap和ConcurrentHashMap区别
jdk1.8/jdk1.7都分别新增了哪些特性？

面向对象和面向过程的区别
什么是字节码?采用字节码的好处是什么?
Java 应用程序与小程序之间有那些差别
在一个静态方法内调用一个非静态成员为什么是非法的
在 Java 中定义一个不做事且没有参数的构造方法的作用
